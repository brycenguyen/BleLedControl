; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\_build\ble_advdata.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\ble_advdata.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\include -I..\..\..\rbc_mesh -I..\..\..\rbc_mesh\include -I..\..\..\SDK\bsp -I..\..\..\..\..\..\components\softdevice\s110\headers -I..\..\..\..\..\..\components\toolchain\gcc -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\libraries\fifo -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\config -I..\..\..\..\..\..\components\drivers_nrf\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\7.2.1\Device\Include -D__MICROLIB -DNRF51 -DBOARD_RHC -DNRF51 -DBLE_STACK_SUPPORT_REQD -DS110 -DSOFTDEVICE_PRESENT --omf_browse=.\_build\ble_advdata.crf ..\..\..\..\..\..\components\ble\common\ble_advdata.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  name_encode PROC
;;;32     
;;;33     static uint32_t name_encode(const ble_advdata_t * p_advdata,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;34                                 uint8_t             * p_encoded_data,
;;;35                                 uint8_t             * p_len)
;;;36     {
000002  b084              SUB      sp,sp,#0x10
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;37         uint32_t err_code;
;;;38         uint16_t rem_adv_data_len;
;;;39         uint16_t actual_length;
;;;40         uint8_t  adv_data_format;
;;;41         uint8_t  adv_offset;
;;;42     
;;;43         adv_offset = *p_len;
000008  9806              LDR      r0,[sp,#0x18]
00000a  7806              LDRB     r6,[r0,#0]
;;;44     
;;;45     
;;;46         // Check for buffer overflow.
;;;47         if ((adv_offset + ADV_DATA_OFFSET > BLE_GAP_ADV_MAX_SIZE) ||
00000c  1cb0              ADDS     r0,r6,#2
00000e  281f              CMP      r0,#0x1f
000010  dc03              BGT      |L1.26|
;;;48             ((p_advdata->short_name_len + ADV_DATA_OFFSET) > BLE_GAP_ADV_MAX_SIZE))
000012  7860              LDRB     r0,[r4,#1]
000014  1c80              ADDS     r0,r0,#2
000016  281f              CMP      r0,#0x1f
000018  dd02              BLE      |L1.32|
                  |L1.26|
;;;49         {
;;;50             return NRF_ERROR_DATA_SIZE;
00001a  200c              MOVS     r0,#0xc
                  |L1.28|
;;;51         }
;;;52         actual_length = rem_adv_data_len = (BLE_GAP_ADV_MAX_SIZE - adv_offset - ADV_FLAG_OFFSET);
;;;53     
;;;54         // Get GAP device name and length
;;;55         err_code = sd_ble_gap_device_name_get(&p_encoded_data[adv_offset + ADV_DATA_OFFSET],
;;;56                                               &actual_length);
;;;57         if (err_code != NRF_SUCCESS)
;;;58         {
;;;59             return err_code;
;;;60         }
;;;61         
;;;62         // Check if device internd to use short name and it can fit available data size.
;;;63         if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
;;;64         {
;;;65             // Complete device name can fit, setting Complete Name in Adv Data.
;;;66             adv_data_format  = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
;;;67             rem_adv_data_len = actual_length;
;;;68         }
;;;69         else
;;;70         {
;;;71             // Else short name needs to be used. Or application has requested use of short name.
;;;72             adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
;;;73     
;;;74             // If application has set a preference on the short name size, it needs to be considered,
;;;75             // else fit what can be fit.
;;;76             if ((p_advdata->short_name_len != 0) && (p_advdata->short_name_len <= rem_adv_data_len))
;;;77             {
;;;78                 // Short name fits available size.
;;;79                 rem_adv_data_len = p_advdata->short_name_len;
;;;80             }
;;;81             // Else whatever can fit the data buffer will be packed.
;;;82             else
;;;83             {
;;;84                 rem_adv_data_len = actual_length;
;;;85             }
;;;86         }
;;;87     
;;;88         // Complete name field in encoded data.
;;;89         p_encoded_data[adv_offset++] = rem_adv_data_len + 1;
;;;90         p_encoded_data[adv_offset++] = adv_data_format;
;;;91         (*p_len)                    += (rem_adv_data_len + ADV_DATA_OFFSET);
;;;92     
;;;93         return NRF_SUCCESS;
;;;94     }
00001c  b007              ADD      sp,sp,#0x1c
00001e  bdf0              POP      {r4-r7,pc}
                  |L1.32|
000020  201f              MOVS     r0,#0x1f              ;52
000022  1b80              SUBS     r0,r0,r6              ;52
000024  1e80              SUBS     r0,r0,#2              ;52
000026  b285              UXTH     r5,r0                 ;52
000028  9502              STR      r5,[sp,#8]            ;52
00002a  1cb1              ADDS     r1,r6,#2              ;55
00002c  1878              ADDS     r0,r7,r1              ;55
00002e  a902              ADD      r1,sp,#8              ;55
000030  df7d              SVC      #0x7d                 ;55
000032  9003              STR      r0,[sp,#0xc]          ;55
000034  9803              LDR      r0,[sp,#0xc]          ;57
000036  2800              CMP      r0,#0                 ;57
000038  d001              BEQ      |L1.62|
00003a  9803              LDR      r0,[sp,#0xc]          ;59
00003c  e7ee              B        |L1.28|
                  |L1.62|
00003e  7820              LDRB     r0,[r4,#0]            ;63
000040  2802              CMP      r0,#2                 ;63
000042  d108              BNE      |L1.86|
000044  4668              MOV      r0,sp                 ;63
000046  8900              LDRH     r0,[r0,#8]            ;63
000048  42a8              CMP      r0,r5                 ;63
00004a  dc04              BGT      |L1.86|
00004c  2009              MOVS     r0,#9                 ;66
00004e  9001              STR      r0,[sp,#4]            ;66
000050  4668              MOV      r0,sp                 ;67
000052  8905              LDRH     r5,[r0,#8]            ;67
000054  e00b              B        |L1.110|
                  |L1.86|
000056  2008              MOVS     r0,#8                 ;72
000058  9001              STR      r0,[sp,#4]            ;72
00005a  7860              LDRB     r0,[r4,#1]            ;76
00005c  2800              CMP      r0,#0                 ;76
00005e  d004              BEQ      |L1.106|
000060  7860              LDRB     r0,[r4,#1]            ;76
000062  42a8              CMP      r0,r5                 ;76
000064  dc01              BGT      |L1.106|
000066  7865              LDRB     r5,[r4,#1]            ;79
000068  e001              B        |L1.110|
                  |L1.106|
00006a  4668              MOV      r0,sp                 ;84
00006c  8905              LDRH     r5,[r0,#8]            ;84
                  |L1.110|
00006e  1c68              ADDS     r0,r5,#1              ;89
000070  b2c2              UXTB     r2,r0                 ;89
000072  4630              MOV      r0,r6                 ;89
000074  1c71              ADDS     r1,r6,#1              ;89
000076  b2ce              UXTB     r6,r1                 ;89
000078  543a              STRB     r2,[r7,r0]            ;89
00007a  4630              MOV      r0,r6                 ;90
00007c  1c72              ADDS     r2,r6,#1              ;90
00007e  b2d6              UXTB     r6,r2                 ;90
000080  9901              LDR      r1,[sp,#4]            ;90
000082  5439              STRB     r1,[r7,r0]            ;90
000084  9806              LDR      r0,[sp,#0x18]         ;91
000086  7801              LDRB     r1,[r0,#0]            ;91
000088  1ca8              ADDS     r0,r5,#2              ;91
00008a  1808              ADDS     r0,r1,r0              ;91
00008c  b2c1              UXTB     r1,r0                 ;91
00008e  9806              LDR      r0,[sp,#0x18]         ;91
000090  7001              STRB     r1,[r0,#0]            ;91
000092  2000              MOVS     r0,#0                 ;93
000094  e7c2              B        |L1.28|
;;;95     
                          ENDP

                  appearance_encode PROC
;;;96     
;;;97     static uint32_t appearance_encode(uint8_t * p_encoded_data, uint8_t * p_len)
000096  b5f8              PUSH     {r3-r7,lr}
;;;98     {
000098  4605              MOV      r5,r0
00009a  460c              MOV      r4,r1
;;;99         uint32_t err_code;
;;;100        uint16_t appearance;
;;;101    
;;;102        // Check for buffer overflow.
;;;103        if ((*p_len) + 4 > BLE_GAP_ADV_MAX_SIZE)
00009c  7820              LDRB     r0,[r4,#0]
00009e  1d00              ADDS     r0,r0,#4
0000a0  281f              CMP      r0,#0x1f
0000a2  dd01              BLE      |L1.168|
;;;104        {
;;;105            return NRF_ERROR_DATA_SIZE;
0000a4  200c              MOVS     r0,#0xc
                  |L1.166|
;;;106        }
;;;107    
;;;108        // Get GAP appearance field.
;;;109        err_code = sd_ble_gap_appearance_get(&appearance);
;;;110        if (err_code != NRF_SUCCESS)
;;;111        {
;;;112            return err_code;
;;;113        }
;;;114    
;;;115        // Encode Length, AD Type and Appearance.
;;;116        p_encoded_data[(*p_len)++] = 3;
;;;117        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_APPEARANCE;
;;;118    
;;;119        (*p_len) += uint16_encode(appearance, &p_encoded_data[*p_len]);
;;;120    
;;;121        return NRF_SUCCESS;
;;;122    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L1.168|
0000a8  4668              MOV      r0,sp                 ;109
0000aa  df79              SVC      #0x79                 ;109
0000ac  4606              MOV      r6,r0                 ;109
0000ae  2e00              CMP      r6,#0                 ;110
0000b0  d001              BEQ      |L1.182|
0000b2  4630              MOV      r0,r6                 ;112
0000b4  e7f7              B        |L1.166|
                  |L1.182|
0000b6  2103              MOVS     r1,#3                 ;116
0000b8  7822              LDRB     r2,[r4,#0]            ;116
0000ba  1c50              ADDS     r0,r2,#1              ;116
0000bc  7020              STRB     r0,[r4,#0]            ;116
0000be  54a9              STRB     r1,[r5,r2]            ;116
0000c0  2119              MOVS     r1,#0x19              ;117
0000c2  7822              LDRB     r2,[r4,#0]            ;117
0000c4  1c50              ADDS     r0,r2,#1              ;117
0000c6  7020              STRB     r0,[r4,#0]            ;117
0000c8  54a9              STRB     r1,[r5,r2]            ;117
0000ca  7820              LDRB     r0,[r4,#0]            ;119
0000cc  1941              ADDS     r1,r0,r5              ;119
0000ce  4668              MOV      r0,sp                 ;119
0000d0  8800              LDRH     r0,[r0,#0]            ;119
0000d2  f7fffffe          BL       uint16_encode
0000d6  7821              LDRB     r1,[r4,#0]            ;119
0000d8  1840              ADDS     r0,r0,r1              ;119
0000da  7020              STRB     r0,[r4,#0]            ;119
0000dc  2000              MOVS     r0,#0                 ;121
0000de  e7e2              B        |L1.166|
;;;123    
                          ENDP

                  tx_power_level_encode PROC
;;;124    
;;;125    static uint32_t tx_power_level_encode(int8_t    tx_power_level,
0000e0  b530              PUSH     {r4,r5,lr}
;;;126                                          uint8_t * p_encoded_data,
;;;127                                          uint8_t * p_len)
;;;128    {
0000e2  4603              MOV      r3,r0
;;;129        // Check for buffer overflow.
;;;130        if ((*p_len) + 3 > BLE_GAP_ADV_MAX_SIZE)
0000e4  7810              LDRB     r0,[r2,#0]
0000e6  1cc0              ADDS     r0,r0,#3
0000e8  281f              CMP      r0,#0x1f
0000ea  dd01              BLE      |L1.240|
;;;131        {
;;;132            return NRF_ERROR_DATA_SIZE;
0000ec  200c              MOVS     r0,#0xc
                  |L1.238|
;;;133        }
;;;134    
;;;135        // Encode TX Power Level.
;;;136        p_encoded_data[(*p_len)++] = 2;
;;;137        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
;;;138        p_encoded_data[(*p_len)++] = (uint8_t)tx_power_level;
;;;139    
;;;140        return NRF_SUCCESS;
;;;141    }
0000ee  bd30              POP      {r4,r5,pc}
                  |L1.240|
0000f0  2402              MOVS     r4,#2                 ;136
0000f2  7815              LDRB     r5,[r2,#0]            ;136
0000f4  1c68              ADDS     r0,r5,#1              ;136
0000f6  7010              STRB     r0,[r2,#0]            ;136
0000f8  554c              STRB     r4,[r1,r5]            ;136
0000fa  240a              MOVS     r4,#0xa               ;137
0000fc  7815              LDRB     r5,[r2,#0]            ;137
0000fe  1c68              ADDS     r0,r5,#1              ;137
000100  7010              STRB     r0,[r2,#0]            ;137
000102  554c              STRB     r4,[r1,r5]            ;137
000104  7815              LDRB     r5,[r2,#0]            ;138
000106  1c68              ADDS     r0,r5,#1              ;138
000108  7010              STRB     r0,[r2,#0]            ;138
00010a  554b              STRB     r3,[r1,r5]            ;138
00010c  2000              MOVS     r0,#0                 ;140
00010e  e7ee              B        |L1.238|
;;;142    
                          ENDP

                  uuid_list_sized_encode PROC
;;;143    
;;;144    static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000110  b5ff              PUSH     {r0-r7,lr}
;;;145                                           uint8_t                         adv_type,
;;;146                                           uint8_t                         uuid_size,
;;;147                                           uint8_t                       * p_encoded_data,
;;;148                                           uint8_t                       * p_len)
;;;149    {
000112  b087              SUB      sp,sp,#0x1c
000114  4606              MOV      r6,r0
000116  461d              MOV      r5,r3
000118  9c10              LDR      r4,[sp,#0x40]
;;;150        int     i;
;;;151        bool    is_heading_written = false;
00011a  2000              MOVS     r0,#0
00011c  9006              STR      r0,[sp,#0x18]
;;;152        uint8_t start_pos          = *p_len;
00011e  7820              LDRB     r0,[r4,#0]
000120  9005              STR      r0,[sp,#0x14]
;;;153    
;;;154        for (i = 0; i < p_uuid_list->uuid_cnt; i++)
000122  2700              MOVS     r7,#0
000124  e047              B        |L1.438|
                  |L1.294|
;;;155        {
;;;156            uint32_t   err_code;
;;;157            uint8_t    encoded_size;
;;;158            ble_uuid_t uuid = p_uuid_list->p_uuids[i];
000126  00b9              LSLS     r1,r7,#2
000128  6870              LDR      r0,[r6,#4]
00012a  1841              ADDS     r1,r0,r1
00012c  880a              LDRH     r2,[r1,#0]
00012e  4668              MOV      r0,sp
000130  8102              STRH     r2,[r0,#8]
000132  8849              LDRH     r1,[r1,#2]
000134  8141              STRH     r1,[r0,#0xa]
;;;159            
;;;160            // Find encoded uuid size.
;;;161            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
000136  2200              MOVS     r2,#0
000138  a903              ADD      r1,sp,#0xc
00013a  a802              ADD      r0,sp,#8
00013c  df65              SVC      #0x65
00013e  9004              STR      r0,[sp,#0x10]
;;;162            if (err_code != NRF_SUCCESS)
000140  9804              LDR      r0,[sp,#0x10]
000142  2800              CMP      r0,#0
000144  d002              BEQ      |L1.332|
;;;163            {
;;;164                return err_code;
000146  9804              LDR      r0,[sp,#0x10]
                  |L1.328|
;;;165            }
;;;166    
;;;167            // Check size.
;;;168            if (encoded_size == uuid_size)
;;;169            {
;;;170                uint8_t heading_bytes = (is_heading_written) ? 0 : 2;
;;;171                
;;;172                // Check for buffer overflow
;;;173                if (*p_len + encoded_size + heading_bytes > BLE_GAP_ADV_MAX_SIZE)
;;;174                {
;;;175                    return NRF_ERROR_DATA_SIZE;
;;;176                }
;;;177    
;;;178                if (!is_heading_written)
;;;179                {
;;;180                    // Write AD structure heading.
;;;181                    (*p_len)++;
;;;182                    p_encoded_data[(*p_len)++] = adv_type;
;;;183                    is_heading_written         = true;
;;;184                }
;;;185    
;;;186                // Write UUID.
;;;187                err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_len]);
;;;188                if (err_code != NRF_SUCCESS)
;;;189                {
;;;190                    return err_code;
;;;191                }
;;;192                (*p_len) += encoded_size;
;;;193            }
;;;194        }
;;;195    
;;;196        if (is_heading_written)
;;;197        {
;;;198            // Write length.
;;;199            p_encoded_data[start_pos] = (*p_len) - (start_pos + 1);
;;;200        }
;;;201    
;;;202        return NRF_SUCCESS;
;;;203    }
000148  b00b              ADD      sp,sp,#0x2c
00014a  bdf0              POP      {r4-r7,pc}
                  |L1.332|
00014c  4668              MOV      r0,sp                 ;168
00014e  7b01              LDRB     r1,[r0,#0xc]          ;168
000150  9809              LDR      r0,[sp,#0x24]         ;168
000152  4281              CMP      r1,r0                 ;168
000154  d12e              BNE      |L1.436|
000156  9806              LDR      r0,[sp,#0x18]         ;170
000158  2800              CMP      r0,#0                 ;170
00015a  d001              BEQ      |L1.352|
00015c  2000              MOVS     r0,#0                 ;170
00015e  e000              B        |L1.354|
                  |L1.352|
000160  2002              MOVS     r0,#2                 ;170
                  |L1.354|
000162  9001              STR      r0,[sp,#4]            ;170
000164  7820              LDRB     r0,[r4,#0]            ;173
000166  4669              MOV      r1,sp                 ;173
000168  7b09              LDRB     r1,[r1,#0xc]          ;173
00016a  1841              ADDS     r1,r0,r1              ;173
00016c  9801              LDR      r0,[sp,#4]            ;173
00016e  1808              ADDS     r0,r1,r0              ;173
000170  281f              CMP      r0,#0x1f              ;173
000172  dd01              BLE      |L1.376|
000174  200c              MOVS     r0,#0xc               ;175
000176  e7e7              B        |L1.328|
                  |L1.376|
000178  9806              LDR      r0,[sp,#0x18]         ;178
00017a  2800              CMP      r0,#0                 ;178
00017c  d109              BNE      |L1.402|
00017e  7820              LDRB     r0,[r4,#0]            ;181
000180  1c40              ADDS     r0,r0,#1              ;181
000182  7020              STRB     r0,[r4,#0]            ;181
000184  7822              LDRB     r2,[r4,#0]            ;182
000186  1c51              ADDS     r1,r2,#1              ;182
000188  9808              LDR      r0,[sp,#0x20]         ;182
00018a  7021              STRB     r1,[r4,#0]            ;182
00018c  54a8              STRB     r0,[r5,r2]            ;182
00018e  2001              MOVS     r0,#1                 ;183
000190  9006              STR      r0,[sp,#0x18]         ;183
                  |L1.402|
000192  7820              LDRB     r0,[r4,#0]            ;187
000194  1942              ADDS     r2,r0,r5              ;187
000196  a903              ADD      r1,sp,#0xc            ;187
000198  a802              ADD      r0,sp,#8              ;187
00019a  df65              SVC      #0x65                 ;187
00019c  9004              STR      r0,[sp,#0x10]         ;187
00019e  9804              LDR      r0,[sp,#0x10]         ;188
0001a0  2800              CMP      r0,#0                 ;188
0001a2  d001              BEQ      |L1.424|
0001a4  9804              LDR      r0,[sp,#0x10]         ;190
0001a6  e7cf              B        |L1.328|
                  |L1.424|
0001a8  7820              LDRB     r0,[r4,#0]            ;192
0001aa  4669              MOV      r1,sp                 ;192
0001ac  7b09              LDRB     r1,[r1,#0xc]          ;192
0001ae  1840              ADDS     r0,r0,r1              ;192
0001b0  7020              STRB     r0,[r4,#0]            ;192
0001b2  bf00              NOP                            ;193
                  |L1.436|
0001b4  1c7f              ADDS     r7,r7,#1              ;154
                  |L1.438|
0001b6  8830              LDRH     r0,[r6,#0]            ;154
0001b8  42b8              CMP      r0,r7                 ;154
0001ba  dcb4              BGT      |L1.294|
0001bc  9806              LDR      r0,[sp,#0x18]         ;196
0001be  2800              CMP      r0,#0                 ;196
0001c0  d006              BEQ      |L1.464|
0001c2  7821              LDRB     r1,[r4,#0]            ;199
0001c4  9805              LDR      r0,[sp,#0x14]         ;199
0001c6  1c40              ADDS     r0,r0,#1              ;199
0001c8  1a08              SUBS     r0,r1,r0              ;199
0001ca  b2c1              UXTB     r1,r0                 ;199
0001cc  9805              LDR      r0,[sp,#0x14]         ;199
0001ce  5429              STRB     r1,[r5,r0]            ;199
                  |L1.464|
0001d0  2000              MOVS     r0,#0                 ;202
0001d2  e7b9              B        |L1.328|
;;;204    
                          ENDP

                  uuid_list_encode PROC
;;;205    
;;;206    static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
0001d4  b5ff              PUSH     {r0-r7,lr}
;;;207                                     uint8_t                         adv_type_16,
;;;208                                     uint8_t                         adv_type_128,
;;;209                                     uint8_t                       * p_encoded_data,
;;;210                                     uint8_t                       * p_len)
;;;211    {
0001d6  b081              SUB      sp,sp,#4
0001d8  4607              MOV      r7,r0
0001da  4615              MOV      r5,r2
0001dc  9e0a              LDR      r6,[sp,#0x28]
;;;212        uint32_t err_code;
;;;213    
;;;214        // Encode 16 bit UUIDs.
;;;215        err_code = uuid_list_sized_encode(p_uuid_list,
0001de  9600              STR      r6,[sp,#0]
0001e0  2202              MOVS     r2,#2
0001e2  4638              MOV      r0,r7
0001e4  9b04              LDR      r3,[sp,#0x10]
0001e6  9902              LDR      r1,[sp,#8]
0001e8  f7fffffe          BL       uuid_list_sized_encode
0001ec  4604              MOV      r4,r0
;;;216                                          adv_type_16,
;;;217                                          sizeof(uint16_le_t),
;;;218                                          p_encoded_data,
;;;219                                          p_len);
;;;220        if (err_code != NRF_SUCCESS)
0001ee  2c00              CMP      r4,#0
0001f0  d002              BEQ      |L1.504|
;;;221        {
;;;222            return err_code;
0001f2  4620              MOV      r0,r4
                  |L1.500|
;;;223        }
;;;224    
;;;225        // Encode 128 bit UUIDs.
;;;226        err_code = uuid_list_sized_encode(p_uuid_list,
;;;227                                          adv_type_128,
;;;228                                          sizeof(ble_uuid128_t),
;;;229                                          p_encoded_data,
;;;230                                          p_len);
;;;231        if (err_code != NRF_SUCCESS)
;;;232        {
;;;233            return err_code;
;;;234        }
;;;235    
;;;236        return NRF_SUCCESS;
;;;237    }
0001f4  b005              ADD      sp,sp,#0x14
0001f6  bdf0              POP      {r4-r7,pc}
                  |L1.504|
0001f8  9600              STR      r6,[sp,#0]            ;226
0001fa  2210              MOVS     r2,#0x10              ;226
0001fc  4629              MOV      r1,r5                 ;226
0001fe  4638              MOV      r0,r7                 ;226
000200  9b04              LDR      r3,[sp,#0x10]         ;226
000202  f7fffffe          BL       uuid_list_sized_encode
000206  4604              MOV      r4,r0                 ;226
000208  2c00              CMP      r4,#0                 ;231
00020a  d001              BEQ      |L1.528|
00020c  4620              MOV      r0,r4                 ;233
00020e  e7f1              B        |L1.500|
                  |L1.528|
000210  2000              MOVS     r0,#0                 ;236
000212  e7ef              B        |L1.500|
;;;238    
                          ENDP

                  conn_int_check PROC
;;;239    
;;;240    static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
000214  4601              MOV      r1,r0
;;;241    {
;;;242        // Check Minimum Connection Interval.
;;;243        if ((p_conn_int->min_conn_interval < 0x0006) ||
000216  8808              LDRH     r0,[r1,#0]
000218  2806              CMP      r0,#6
00021a  db08              BLT      |L1.558|
;;;244            (
;;;245                (p_conn_int->min_conn_interval > 0x0c80) &&
00021c  8808              LDRH     r0,[r1,#0]
00021e  2219              MOVS     r2,#0x19
000220  01d2              LSLS     r2,r2,#7
000222  4290              CMP      r0,r2
000224  dd05              BLE      |L1.562|
;;;246                (p_conn_int->min_conn_interval != 0xffff)
000226  8808              LDRH     r0,[r1,#0]
000228  4ade              LDR      r2,|L1.1444|
00022a  4290              CMP      r0,r2
00022c  d001              BEQ      |L1.562|
                  |L1.558|
;;;247            )
;;;248           )
;;;249        {
;;;250            return NRF_ERROR_INVALID_PARAM;
00022e  2007              MOVS     r0,#7
                  |L1.560|
;;;251        }
;;;252    
;;;253        // Check Maximum Connection Interval.
;;;254        if ((p_conn_int->max_conn_interval < 0x0006) || 
;;;255            (
;;;256                (p_conn_int->max_conn_interval > 0x0c80) && 
;;;257                (p_conn_int->max_conn_interval != 0xffff)
;;;258            )
;;;259           )
;;;260        {
;;;261            return NRF_ERROR_INVALID_PARAM;
;;;262        }
;;;263    
;;;264        // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
;;;265        if ((p_conn_int->min_conn_interval != 0xffff) &&
;;;266            (p_conn_int->max_conn_interval != 0xffff) &&
;;;267            (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
;;;268            )
;;;269        {
;;;270            return NRF_ERROR_INVALID_PARAM;
;;;271        }
;;;272    
;;;273        return NRF_SUCCESS;
;;;274    }
000230  4770              BX       lr
                  |L1.562|
000232  8848              LDRH     r0,[r1,#2]            ;254
000234  2806              CMP      r0,#6                 ;254
000236  db08              BLT      |L1.586|
000238  8848              LDRH     r0,[r1,#2]            ;256
00023a  2219              MOVS     r2,#0x19              ;256
00023c  01d2              LSLS     r2,r2,#7              ;256
00023e  4290              CMP      r0,r2                 ;256
000240  dd05              BLE      |L1.590|
000242  8848              LDRH     r0,[r1,#2]            ;257
000244  4ad7              LDR      r2,|L1.1444|
000246  4290              CMP      r0,r2                 ;257
000248  d001              BEQ      |L1.590|
                  |L1.586|
00024a  2007              MOVS     r0,#7                 ;261
00024c  e7f0              B        |L1.560|
                  |L1.590|
00024e  8808              LDRH     r0,[r1,#0]            ;265
000250  4ad4              LDR      r2,|L1.1444|
000252  4290              CMP      r0,r2                 ;265
000254  d008              BEQ      |L1.616|
000256  8848              LDRH     r0,[r1,#2]            ;266
000258  4290              CMP      r0,r2                 ;266
00025a  d005              BEQ      |L1.616|
00025c  8808              LDRH     r0,[r1,#0]            ;267
00025e  884a              LDRH     r2,[r1,#2]            ;267
000260  4290              CMP      r0,r2                 ;267
000262  dd01              BLE      |L1.616|
000264  2007              MOVS     r0,#7                 ;270
000266  e7e3              B        |L1.560|
                  |L1.616|
000268  2000              MOVS     r0,#0                 ;273
00026a  e7e1              B        |L1.560|
;;;275    
                          ENDP

                  conn_int_encode PROC
;;;276    
;;;277    static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
00026c  b5f8              PUSH     {r3-r7,lr}
;;;278                                    uint8_t                      * p_encoded_data,
;;;279                                    uint8_t                      * p_len)
;;;280    {
00026e  4606              MOV      r6,r0
000270  460d              MOV      r5,r1
000272  4614              MOV      r4,r2
;;;281        uint32_t err_code;
;;;282    
;;;283        // Check for buffer overflow.
;;;284        if ((*p_len) + ADV_DATA_OFFSET + 2 * sizeof(uint16_le_t) > BLE_GAP_ADV_MAX_SIZE)
000274  7820              LDRB     r0,[r4,#0]
000276  1d80              ADDS     r0,r0,#6
000278  281f              CMP      r0,#0x1f
00027a  d901              BLS      |L1.640|
;;;285        {
;;;286            return NRF_ERROR_DATA_SIZE;
00027c  200c              MOVS     r0,#0xc
                  |L1.638|
;;;287        }
;;;288    
;;;289        // Check parameters.
;;;290        err_code = conn_int_check(p_conn_int);
;;;291        if (err_code != NRF_SUCCESS)
;;;292        {
;;;293            return err_code;
;;;294        }
;;;295    
;;;296        // Encode Length and AD Type.
;;;297        p_encoded_data[(*p_len)++] = 1 + 2 * sizeof(uint16_le_t);
;;;298        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
;;;299    
;;;300        // Encode Minimum and Maximum Connection Intervals.
;;;301        (*p_len) += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_len]);
;;;302        (*p_len) += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_len]);
;;;303    
;;;304        return NRF_SUCCESS;
;;;305    }
00027e  bdf8              POP      {r3-r7,pc}
                  |L1.640|
000280  4630              MOV      r0,r6                 ;290
000282  f7fffffe          BL       conn_int_check
000286  4607              MOV      r7,r0                 ;290
000288  2f00              CMP      r7,#0                 ;291
00028a  d001              BEQ      |L1.656|
00028c  4638              MOV      r0,r7                 ;293
00028e  e7f6              B        |L1.638|
                  |L1.656|
000290  2105              MOVS     r1,#5                 ;297
000292  7822              LDRB     r2,[r4,#0]            ;297
000294  1c50              ADDS     r0,r2,#1              ;297
000296  7020              STRB     r0,[r4,#0]            ;297
000298  54a9              STRB     r1,[r5,r2]            ;297
00029a  2112              MOVS     r1,#0x12              ;298
00029c  7822              LDRB     r2,[r4,#0]            ;298
00029e  1c50              ADDS     r0,r2,#1              ;298
0002a0  7020              STRB     r0,[r4,#0]            ;298
0002a2  54a9              STRB     r1,[r5,r2]            ;298
0002a4  7822              LDRB     r2,[r4,#0]            ;301
0002a6  1951              ADDS     r1,r2,r5              ;301
0002a8  8830              LDRH     r0,[r6,#0]            ;301
0002aa  f7fffffe          BL       uint16_encode
0002ae  7821              LDRB     r1,[r4,#0]            ;301
0002b0  1840              ADDS     r0,r0,r1              ;301
0002b2  7020              STRB     r0,[r4,#0]            ;301
0002b4  7822              LDRB     r2,[r4,#0]            ;302
0002b6  1951              ADDS     r1,r2,r5              ;302
0002b8  8870              LDRH     r0,[r6,#2]            ;302
0002ba  f7fffffe          BL       uint16_encode
0002be  7821              LDRB     r1,[r4,#0]            ;302
0002c0  1840              ADDS     r0,r0,r1              ;302
0002c2  7020              STRB     r0,[r4,#0]            ;302
0002c4  2000              MOVS     r0,#0                 ;304
0002c6  e7da              B        |L1.638|
;;;306    
                          ENDP

                  manuf_specific_data_encode PROC
;;;307    
;;;308    static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
0002c8  b5f8              PUSH     {r3-r7,lr}
;;;309                                               uint8_t                        * p_encoded_data,
;;;310                                               uint8_t                        * p_len)
;;;311    {
0002ca  4605              MOV      r5,r0
0002cc  460e              MOV      r6,r1
0002ce  4614              MOV      r4,r2
;;;312        uint8_t data_size = sizeof(uint16_le_t) + p_manuf_sp_data->data.size;
0002d0  7928              LDRB     r0,[r5,#4]
0002d2  1c80              ADDS     r0,r0,#2
0002d4  b2c7              UXTB     r7,r0
;;;313    
;;;314        // Check for buffer overflow.
;;;315        if ((*p_len) + ADV_DATA_OFFSET + data_size > BLE_GAP_ADV_MAX_SIZE)
0002d6  7820              LDRB     r0,[r4,#0]
0002d8  1c80              ADDS     r0,r0,#2
0002da  19c0              ADDS     r0,r0,r7
0002dc  281f              CMP      r0,#0x1f
0002de  dd01              BLE      |L1.740|
;;;316        {
;;;317            return NRF_ERROR_DATA_SIZE;
0002e0  200c              MOVS     r0,#0xc
                  |L1.738|
;;;318        }
;;;319    
;;;320        // Encode Length and AD Type.
;;;321        p_encoded_data[(*p_len)++] = 1 + data_size;
;;;322        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
;;;323        
;;;324        // Encode Company Identifier.
;;;325        (*p_len) += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_len]);
;;;326        
;;;327        // Encode additional manufacturer specific data.
;;;328        if (p_manuf_sp_data->data.size > 0)
;;;329        {
;;;330            if (p_manuf_sp_data->data.p_data == NULL)
;;;331            {
;;;332                return NRF_ERROR_INVALID_PARAM;
;;;333            }
;;;334            memcpy(&p_encoded_data[*p_len], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
;;;335            (*p_len) += p_manuf_sp_data->data.size;
;;;336        }
;;;337    
;;;338        return NRF_SUCCESS;
;;;339    }
0002e2  bdf8              POP      {r3-r7,pc}
                  |L1.740|
0002e4  1c78              ADDS     r0,r7,#1              ;321
0002e6  b2c1              UXTB     r1,r0                 ;321
0002e8  7822              LDRB     r2,[r4,#0]            ;321
0002ea  1c50              ADDS     r0,r2,#1              ;321
0002ec  7020              STRB     r0,[r4,#0]            ;321
0002ee  54b1              STRB     r1,[r6,r2]            ;321
0002f0  21ff              MOVS     r1,#0xff              ;322
0002f2  7822              LDRB     r2,[r4,#0]            ;322
0002f4  1c50              ADDS     r0,r2,#1              ;322
0002f6  7020              STRB     r0,[r4,#0]            ;322
0002f8  54b1              STRB     r1,[r6,r2]            ;322
0002fa  7822              LDRB     r2,[r4,#0]            ;325
0002fc  1991              ADDS     r1,r2,r6              ;325
0002fe  8828              LDRH     r0,[r5,#0]            ;325
000300  f7fffffe          BL       uint16_encode
000304  7821              LDRB     r1,[r4,#0]            ;325
000306  1840              ADDS     r0,r0,r1              ;325
000308  7020              STRB     r0,[r4,#0]            ;325
00030a  88a8              LDRH     r0,[r5,#4]            ;328
00030c  2800              CMP      r0,#0                 ;328
00030e  dd0e              BLE      |L1.814|
000310  68a8              LDR      r0,[r5,#8]            ;330
000312  2800              CMP      r0,#0                 ;330
000314  d101              BNE      |L1.794|
000316  2007              MOVS     r0,#7                 ;332
000318  e7e3              B        |L1.738|
                  |L1.794|
00031a  88aa              LDRH     r2,[r5,#4]            ;334
00031c  7823              LDRB     r3,[r4,#0]            ;334
00031e  1998              ADDS     r0,r3,r6              ;334
000320  68a9              LDR      r1,[r5,#8]            ;334
000322  f7fffffe          BL       __aeabi_memcpy
000326  7820              LDRB     r0,[r4,#0]            ;335
000328  7929              LDRB     r1,[r5,#4]            ;335
00032a  1840              ADDS     r0,r0,r1              ;335
00032c  7020              STRB     r0,[r4,#0]            ;335
                  |L1.814|
00032e  2000              MOVS     r0,#0                 ;338
000330  e7d7              B        |L1.738|
;;;340    
                          ENDP

                  service_data_encode PROC
;;;341    
;;;342    static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
000332  b5fe              PUSH     {r1-r7,lr}
;;;343                                        uint8_t             * p_encoded_data,
;;;344                                        uint8_t             * p_len)
;;;345    {
000334  4607              MOV      r7,r0
000336  460e              MOV      r6,r1
000338  4614              MOV      r4,r2
;;;346        uint8_t i;
;;;347    
;;;348        // Check parameter consistency.
;;;349        if (p_advdata->p_service_data_array == NULL)
00033a  6ab8              LDR      r0,[r7,#0x28]
00033c  2800              CMP      r0,#0
00033e  d101              BNE      |L1.836|
;;;350        {
;;;351            return NRF_ERROR_INVALID_PARAM;
000340  2007              MOVS     r0,#7
                  |L1.834|
;;;352        }
;;;353    
;;;354        for (i = 0; i < p_advdata->service_data_count; i++)
;;;355        {
;;;356            ble_advdata_service_data_t * p_service_data;
;;;357            uint8_t                      data_size;
;;;358    
;;;359            p_service_data = &p_advdata->p_service_data_array[i];
;;;360            data_size      = sizeof(uint16_le_t) + p_service_data->data.size;
;;;361    
;;;362            // Encode Length and AD Type.
;;;363            p_encoded_data[(*p_len)++] = 1 + data_size;
;;;364            p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SERVICE_DATA;
;;;365    
;;;366            // Encode service UUID.
;;;367            (*p_len) += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_len]);
;;;368    
;;;369            // Encode additional service data.
;;;370            if (p_service_data->data.size > 0)
;;;371            {
;;;372                if (p_service_data->data.p_data == NULL)
;;;373                {
;;;374                    return NRF_ERROR_INVALID_PARAM;
;;;375                }
;;;376                memcpy(&p_encoded_data[*p_len], p_service_data->data.p_data, p_service_data->data.size);
;;;377                (*p_len) += p_service_data->data.size;
;;;378            }
;;;379        }
;;;380    
;;;381        return NRF_SUCCESS;
;;;382    }
000342  bdfe              POP      {r1-r7,pc}
                  |L1.836|
000344  2000              MOVS     r0,#0                 ;354
000346  9001              STR      r0,[sp,#4]            ;354
000348  e032              B        |L1.944|
                  |L1.842|
00034a  6ab9              LDR      r1,[r7,#0x28]         ;359
00034c  220c              MOVS     r2,#0xc               ;359
00034e  9801              LDR      r0,[sp,#4]            ;359
000350  4350              MULS     r0,r2,r0              ;359
000352  180d              ADDS     r5,r1,r0              ;359
000354  7928              LDRB     r0,[r5,#4]            ;360
000356  1c80              ADDS     r0,r0,#2              ;360
000358  b2c0              UXTB     r0,r0                 ;360
00035a  9000              STR      r0,[sp,#0]            ;360
00035c  9800              LDR      r0,[sp,#0]            ;363
00035e  1c40              ADDS     r0,r0,#1              ;363
000360  b2c1              UXTB     r1,r0                 ;363
000362  7822              LDRB     r2,[r4,#0]            ;363
000364  1c50              ADDS     r0,r2,#1              ;363
000366  7020              STRB     r0,[r4,#0]            ;363
000368  54b1              STRB     r1,[r6,r2]            ;363
00036a  2116              MOVS     r1,#0x16              ;364
00036c  7822              LDRB     r2,[r4,#0]            ;364
00036e  1c50              ADDS     r0,r2,#1              ;364
000370  7020              STRB     r0,[r4,#0]            ;364
000372  54b1              STRB     r1,[r6,r2]            ;364
000374  7822              LDRB     r2,[r4,#0]            ;367
000376  1991              ADDS     r1,r2,r6              ;367
000378  8828              LDRH     r0,[r5,#0]            ;367
00037a  f7fffffe          BL       uint16_encode
00037e  7821              LDRB     r1,[r4,#0]            ;367
000380  1840              ADDS     r0,r0,r1              ;367
000382  7020              STRB     r0,[r4,#0]            ;367
000384  88a8              LDRH     r0,[r5,#4]            ;370
000386  2800              CMP      r0,#0                 ;370
000388  dd0e              BLE      |L1.936|
00038a  68a8              LDR      r0,[r5,#8]            ;372
00038c  2800              CMP      r0,#0                 ;372
00038e  d101              BNE      |L1.916|
000390  2007              MOVS     r0,#7                 ;374
000392  e7d6              B        |L1.834|
                  |L1.916|
000394  88aa              LDRH     r2,[r5,#4]            ;376
000396  7823              LDRB     r3,[r4,#0]            ;376
000398  1998              ADDS     r0,r3,r6              ;376
00039a  68a9              LDR      r1,[r5,#8]            ;376
00039c  f7fffffe          BL       __aeabi_memcpy
0003a0  7820              LDRB     r0,[r4,#0]            ;377
0003a2  7929              LDRB     r1,[r5,#4]            ;377
0003a4  1840              ADDS     r0,r0,r1              ;377
0003a6  7020              STRB     r0,[r4,#0]            ;377
                  |L1.936|
0003a8  9801              LDR      r0,[sp,#4]            ;354
0003aa  1c40              ADDS     r0,r0,#1              ;354
0003ac  b2c0              UXTB     r0,r0                 ;354
0003ae  9001              STR      r0,[sp,#4]            ;354
                  |L1.944|
0003b0  202c              MOVS     r0,#0x2c              ;354
0003b2  5dc1              LDRB     r1,[r0,r7]            ;354
0003b4  9801              LDR      r0,[sp,#4]            ;354
0003b6  4281              CMP      r1,r0                 ;354
0003b8  dcc7              BGT      |L1.842|
0003ba  2000              MOVS     r0,#0                 ;381
0003bc  e7c1              B        |L1.834|
;;;383    
                          ENDP

                  adv_data_encode PROC
;;;384    
;;;385    static uint32_t adv_data_encode(const ble_advdata_t * p_advdata,
0003be  b5f8              PUSH     {r3-r7,lr}
;;;386                                    uint8_t             * p_encoded_data,
;;;387                                    uint8_t             * p_len)
;;;388    {
0003c0  4604              MOV      r4,r0
0003c2  460f              MOV      r7,r1
0003c4  4615              MOV      r5,r2
;;;389        uint32_t err_code = NRF_SUCCESS;
0003c6  2600              MOVS     r6,#0
;;;390    
;;;391        *p_len = 0;
0003c8  2000              MOVS     r0,#0
0003ca  7028              STRB     r0,[r5,#0]
;;;392    
;;;393        // Encode name.
;;;394        if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
0003cc  7820              LDRB     r0,[r4,#0]
0003ce  2800              CMP      r0,#0
0003d0  d009              BEQ      |L1.998|
;;;395        {
;;;396            err_code = name_encode(p_advdata, p_encoded_data, p_len);
0003d2  462a              MOV      r2,r5
0003d4  4639              MOV      r1,r7
0003d6  4620              MOV      r0,r4
0003d8  f7fffffe          BL       name_encode
0003dc  4606              MOV      r6,r0
;;;397            if (err_code != NRF_SUCCESS)
0003de  2e00              CMP      r6,#0
0003e0  d001              BEQ      |L1.998|
;;;398            {
;;;399                return err_code;
0003e2  4630              MOV      r0,r6
                  |L1.996|
;;;400            }
;;;401        }
;;;402    
;;;403        // Encode appearance.
;;;404        if (p_advdata->include_appearance)
;;;405        {
;;;406            err_code = appearance_encode(p_encoded_data, p_len);
;;;407            if (err_code != NRF_SUCCESS)
;;;408            {
;;;409                return err_code;
;;;410            }
;;;411        }
;;;412    
;;;413        if(p_advdata->flags != 0 )
;;;414        {
;;;415            // Encode flags.
;;;416            p_encoded_data[(*p_len)++] = 1 + sizeof(uint8_t);
;;;417            p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_FLAGS;
;;;418            p_encoded_data[(*p_len)++] = p_advdata->flags;
;;;419        } 
;;;420    
;;;421        // Encode TX power level.
;;;422        if (p_advdata->p_tx_power_level != NULL)
;;;423        {
;;;424            err_code = tx_power_level_encode(*p_advdata->p_tx_power_level, p_encoded_data, p_len);
;;;425            if (err_code != NRF_SUCCESS)
;;;426            {
;;;427                return err_code;
;;;428            }
;;;429        }
;;;430        
;;;431        // Encode 'more available' uuid list.
;;;432        if (p_advdata->uuids_more_available.uuid_cnt > 0)
;;;433        {
;;;434            err_code = uuid_list_encode(&p_advdata->uuids_more_available,
;;;435                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;436                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;437                                        p_encoded_data,
;;;438                                        p_len);
;;;439            if (err_code != NRF_SUCCESS)
;;;440            {
;;;441                return err_code;
;;;442            }
;;;443        }
;;;444    
;;;445        // Encode 'complete' uuid list.
;;;446        if (p_advdata->uuids_complete.uuid_cnt > 0)
;;;447        {
;;;448            err_code = uuid_list_encode(&p_advdata->uuids_complete,
;;;449                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
;;;450                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
;;;451                                        p_encoded_data,
;;;452                                        p_len);
;;;453            if (err_code != NRF_SUCCESS)
;;;454            {
;;;455                return err_code;
;;;456            }
;;;457        }
;;;458    
;;;459        // Encode 'solicited service' uuid list.
;;;460        if (p_advdata->uuids_solicited.uuid_cnt > 0)
;;;461        {
;;;462            err_code = uuid_list_encode(&p_advdata->uuids_solicited,
;;;463                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
;;;464                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
;;;465                                        p_encoded_data,
;;;466                                        p_len);
;;;467            if (err_code != NRF_SUCCESS)
;;;468            {
;;;469                return err_code;
;;;470            }
;;;471        }
;;;472    
;;;473        // Encode Slave Connection Interval Range.
;;;474        if (p_advdata->p_slave_conn_int != NULL)
;;;475        {
;;;476            err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len);
;;;477            if (err_code != NRF_SUCCESS)
;;;478            {
;;;479                return err_code;
;;;480            }
;;;481        }
;;;482    
;;;483        // Encode Manufacturer Specific Data.
;;;484        if (p_advdata->p_manuf_specific_data != NULL)
;;;485        {
;;;486            err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
;;;487                                                  p_encoded_data,
;;;488                                                  p_len);
;;;489            if (err_code != NRF_SUCCESS)
;;;490            {
;;;491                return err_code;
;;;492            }
;;;493        }
;;;494    
;;;495        // Encode Service Data.
;;;496        if (p_advdata->service_data_count > 0)
;;;497        {
;;;498            err_code = service_data_encode(p_advdata, p_encoded_data, p_len);
;;;499            if (err_code != NRF_SUCCESS)
;;;500            {
;;;501                return err_code;
;;;502            }
;;;503        }
;;;504    
;;;505        return err_code;
;;;506    }
0003e4  bdf8              POP      {r3-r7,pc}
                  |L1.998|
0003e6  78a0              LDRB     r0,[r4,#2]            ;404
0003e8  2800              CMP      r0,#0                 ;404
0003ea  d008              BEQ      |L1.1022|
0003ec  4629              MOV      r1,r5                 ;406
0003ee  4638              MOV      r0,r7                 ;406
0003f0  f7fffffe          BL       appearance_encode
0003f4  4606              MOV      r6,r0                 ;406
0003f6  2e00              CMP      r6,#0                 ;407
0003f8  d001              BEQ      |L1.1022|
0003fa  4630              MOV      r0,r6                 ;409
0003fc  e7f2              B        |L1.996|
                  |L1.1022|
0003fe  78e0              LDRB     r0,[r4,#3]            ;413
000400  2800              CMP      r0,#0                 ;413
000402  d00e              BEQ      |L1.1058|
000404  2102              MOVS     r1,#2                 ;416
000406  782a              LDRB     r2,[r5,#0]            ;416
000408  1c50              ADDS     r0,r2,#1              ;416
00040a  7028              STRB     r0,[r5,#0]            ;416
00040c  54b9              STRB     r1,[r7,r2]            ;416
00040e  2101              MOVS     r1,#1                 ;417
000410  782a              LDRB     r2,[r5,#0]            ;417
000412  1c50              ADDS     r0,r2,#1              ;417
000414  7028              STRB     r0,[r5,#0]            ;417
000416  54b9              STRB     r1,[r7,r2]            ;417
000418  78e1              LDRB     r1,[r4,#3]            ;418
00041a  782a              LDRB     r2,[r5,#0]            ;418
00041c  1c50              ADDS     r0,r2,#1              ;418
00041e  7028              STRB     r0,[r5,#0]            ;418
000420  54b9              STRB     r1,[r7,r2]            ;418
                  |L1.1058|
000422  6860              LDR      r0,[r4,#4]            ;422
000424  2800              CMP      r0,#0                 ;422
000426  d00b              BEQ      |L1.1088|
000428  2000              MOVS     r0,#0                 ;424
00042a  6861              LDR      r1,[r4,#4]            ;424
00042c  5608              LDRSB    r0,[r1,r0]            ;424
00042e  462a              MOV      r2,r5                 ;424
000430  4639              MOV      r1,r7                 ;424
000432  f7fffffe          BL       tx_power_level_encode
000436  4606              MOV      r6,r0                 ;424
000438  2e00              CMP      r6,#0                 ;425
00043a  d001              BEQ      |L1.1088|
00043c  4630              MOV      r0,r6                 ;427
00043e  e7d1              B        |L1.996|
                  |L1.1088|
000440  8920              LDRH     r0,[r4,#8]            ;432
000442  2800              CMP      r0,#0                 ;432
000444  dd0c              BLE      |L1.1120|
000446  463b              MOV      r3,r7                 ;434
000448  2206              MOVS     r2,#6                 ;434
00044a  2102              MOVS     r1,#2                 ;434
00044c  4620              MOV      r0,r4                 ;434
00044e  3008              ADDS     r0,r0,#8              ;434
000450  9500              STR      r5,[sp,#0]            ;434
000452  f7fffffe          BL       uuid_list_encode
000456  4606              MOV      r6,r0                 ;434
000458  2e00              CMP      r6,#0                 ;439
00045a  d001              BEQ      |L1.1120|
00045c  4630              MOV      r0,r6                 ;441
00045e  e7c1              B        |L1.996|
                  |L1.1120|
000460  8a20              LDRH     r0,[r4,#0x10]         ;446
000462  2800              CMP      r0,#0                 ;446
000464  dd0c              BLE      |L1.1152|
000466  463b              MOV      r3,r7                 ;448
000468  2207              MOVS     r2,#7                 ;448
00046a  2103              MOVS     r1,#3                 ;448
00046c  4620              MOV      r0,r4                 ;448
00046e  3010              ADDS     r0,r0,#0x10           ;448
000470  9500              STR      r5,[sp,#0]            ;448
000472  f7fffffe          BL       uuid_list_encode
000476  4606              MOV      r6,r0                 ;448
000478  2e00              CMP      r6,#0                 ;453
00047a  d001              BEQ      |L1.1152|
00047c  4630              MOV      r0,r6                 ;455
00047e  e7b1              B        |L1.996|
                  |L1.1152|
000480  8b20              LDRH     r0,[r4,#0x18]         ;460
000482  2800              CMP      r0,#0                 ;460
000484  dd0c              BLE      |L1.1184|
000486  463b              MOV      r3,r7                 ;462
000488  2215              MOVS     r2,#0x15              ;462
00048a  2114              MOVS     r1,#0x14              ;462
00048c  4620              MOV      r0,r4                 ;462
00048e  3018              ADDS     r0,r0,#0x18           ;462
000490  9500              STR      r5,[sp,#0]            ;462
000492  f7fffffe          BL       uuid_list_encode
000496  4606              MOV      r6,r0                 ;462
000498  2e00              CMP      r6,#0                 ;467
00049a  d001              BEQ      |L1.1184|
00049c  4630              MOV      r0,r6                 ;469
00049e  e7a1              B        |L1.996|
                  |L1.1184|
0004a0  6a20              LDR      r0,[r4,#0x20]         ;474
0004a2  2800              CMP      r0,#0                 ;474
0004a4  d009              BEQ      |L1.1210|
0004a6  462a              MOV      r2,r5                 ;476
0004a8  4639              MOV      r1,r7                 ;476
0004aa  6a20              LDR      r0,[r4,#0x20]         ;476
0004ac  f7fffffe          BL       conn_int_encode
0004b0  4606              MOV      r6,r0                 ;476
0004b2  2e00              CMP      r6,#0                 ;477
0004b4  d001              BEQ      |L1.1210|
0004b6  4630              MOV      r0,r6                 ;479
0004b8  e794              B        |L1.996|
                  |L1.1210|
0004ba  6a60              LDR      r0,[r4,#0x24]         ;484
0004bc  2800              CMP      r0,#0                 ;484
0004be  d009              BEQ      |L1.1236|
0004c0  462a              MOV      r2,r5                 ;486
0004c2  4639              MOV      r1,r7                 ;486
0004c4  6a60              LDR      r0,[r4,#0x24]         ;486
0004c6  f7fffffe          BL       manuf_specific_data_encode
0004ca  4606              MOV      r6,r0                 ;486
0004cc  2e00              CMP      r6,#0                 ;489
0004ce  d001              BEQ      |L1.1236|
0004d0  4630              MOV      r0,r6                 ;491
0004d2  e787              B        |L1.996|
                  |L1.1236|
0004d4  202c              MOVS     r0,#0x2c              ;496
0004d6  5d00              LDRB     r0,[r0,r4]            ;496
0004d8  2800              CMP      r0,#0                 ;496
0004da  dd09              BLE      |L1.1264|
0004dc  462a              MOV      r2,r5                 ;498
0004de  4639              MOV      r1,r7                 ;498
0004e0  4620              MOV      r0,r4                 ;498
0004e2  f7fffffe          BL       service_data_encode
0004e6  4606              MOV      r6,r0                 ;498
0004e8  2e00              CMP      r6,#0                 ;499
0004ea  d001              BEQ      |L1.1264|
0004ec  4630              MOV      r0,r6                 ;501
0004ee  e779              B        |L1.996|
                  |L1.1264|
0004f0  4630              MOV      r0,r6                 ;505
0004f2  e777              B        |L1.996|
;;;507    
                          ENDP

                  advdata_check PROC
;;;508    
;;;509    static uint32_t advdata_check(const ble_advdata_t * p_advdata)
0004f4  4601              MOV      r1,r0
;;;510    {
;;;511        // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
;;;512        if (
0004f6  78c8              LDRB     r0,[r1,#3]
0004f8  2204              MOVS     r2,#4
0004fa  4010              ANDS     r0,r0,r2
0004fc  2800              CMP      r0,#0
0004fe  d101              BNE      |L1.1284|
;;;513            ((p_advdata->flags & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
;;;514           )
;;;515        {
;;;516            return NRF_ERROR_INVALID_PARAM;
000500  2007              MOVS     r0,#7
                  |L1.1282|
;;;517        }
;;;518    
;;;519        return NRF_SUCCESS;
;;;520    }
000502  4770              BX       lr
                  |L1.1284|
000504  2000              MOVS     r0,#0                 ;519
000506  e7fc              B        |L1.1282|
;;;521    
                          ENDP

                  srdata_check PROC
;;;522    
;;;523    static uint32_t srdata_check(const ble_advdata_t * p_srdata)
000508  4601              MOV      r1,r0
;;;524    {
;;;525        // Flags shall not be included in the scan response data.
;;;526        if (p_srdata->flags)
00050a  78c8              LDRB     r0,[r1,#3]
00050c  2800              CMP      r0,#0
00050e  d001              BEQ      |L1.1300|
;;;527        {
;;;528            return NRF_ERROR_INVALID_PARAM;
000510  2007              MOVS     r0,#7
                  |L1.1298|
;;;529        }
;;;530    
;;;531        return NRF_SUCCESS;
;;;532    }
000512  4770              BX       lr
                  |L1.1300|
000514  2000              MOVS     r0,#0                 ;531
000516  e7fc              B        |L1.1298|
;;;533    
                          ENDP

                  ble_advdata_set PROC
;;;534    
;;;535    uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
000518  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;536    {
00051a  b093              SUB      sp,sp,#0x4c
00051c  460d              MOV      r5,r1
;;;537        uint32_t  err_code;
;;;538        uint8_t   len_advdata = 0;
00051e  2100              MOVS     r1,#0
000520  9112              STR      r1,[sp,#0x48]
;;;539        uint8_t   len_srdata  = 0;
000522  9111              STR      r1,[sp,#0x44]
;;;540        uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
;;;541        uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
;;;542        uint8_t * p_encoded_advdata;
;;;543        uint8_t * p_encoded_srdata;
;;;544    
;;;545        // Encode advertising data (if supplied).
;;;546        if (p_advdata != NULL)
000524  9813              LDR      r0,[sp,#0x4c]
000526  2800              CMP      r0,#0
000528  d014              BEQ      |L1.1364|
;;;547        {
;;;548            err_code = advdata_check(p_advdata);
00052a  9813              LDR      r0,[sp,#0x4c]
00052c  f7fffffe          BL       advdata_check
000530  4604              MOV      r4,r0
;;;549            if (err_code != NRF_SUCCESS)
000532  2c00              CMP      r4,#0
000534  d002              BEQ      |L1.1340|
;;;550            {
;;;551                return err_code;
000536  4620              MOV      r0,r4
                  |L1.1336|
;;;552            }
;;;553    
;;;554            err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
;;;555            if (err_code != NRF_SUCCESS)
;;;556            {
;;;557                return err_code;
;;;558            }
;;;559            p_encoded_advdata = encoded_advdata;
;;;560        }
;;;561        else
;;;562        {
;;;563            p_encoded_advdata = NULL;
;;;564        }
;;;565    
;;;566        // Encode scan response data (if supplied).
;;;567        if (p_srdata != NULL)
;;;568        {
;;;569            err_code = srdata_check(p_srdata);
;;;570            if (err_code != NRF_SUCCESS)
;;;571            {
;;;572                return err_code;
;;;573            }
;;;574    
;;;575            err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
;;;576            if (err_code != NRF_SUCCESS)
;;;577            {
;;;578                return err_code;
;;;579            }
;;;580            p_encoded_srdata = encoded_srdata;
;;;581        }
;;;582        else
;;;583        {
;;;584            p_encoded_srdata = NULL;
;;;585        }
;;;586    
;;;587        // Pass encoded advertising data and/or scan response data to the stack.
;;;588        return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
;;;589    }
000538  b015              ADD      sp,sp,#0x54
00053a  bdf0              POP      {r4-r7,pc}
                  |L1.1340|
00053c  aa12              ADD      r2,sp,#0x48           ;554
00053e  a909              ADD      r1,sp,#0x24           ;554
000540  9813              LDR      r0,[sp,#0x4c]         ;554
000542  f7fffffe          BL       adv_data_encode
000546  4604              MOV      r4,r0                 ;554
000548  2c00              CMP      r4,#0                 ;555
00054a  d001              BEQ      |L1.1360|
00054c  4620              MOV      r0,r4                 ;557
00054e  e7f3              B        |L1.1336|
                  |L1.1360|
000550  ae09              ADD      r6,sp,#0x24           ;559
000552  e000              B        |L1.1366|
                  |L1.1364|
000554  2600              MOVS     r6,#0                 ;563
                  |L1.1366|
000556  2d00              CMP      r5,#0                 ;567
000558  d013              BEQ      |L1.1410|
00055a  4628              MOV      r0,r5                 ;569
00055c  f7fffffe          BL       srdata_check
000560  4604              MOV      r4,r0                 ;569
000562  2c00              CMP      r4,#0                 ;570
000564  d001              BEQ      |L1.1386|
000566  4620              MOV      r0,r4                 ;572
000568  e7e6              B        |L1.1336|
                  |L1.1386|
00056a  aa11              ADD      r2,sp,#0x44           ;575
00056c  a901              ADD      r1,sp,#4              ;575
00056e  4628              MOV      r0,r5                 ;575
000570  f7fffffe          BL       adv_data_encode
000574  4604              MOV      r4,r0                 ;575
000576  2c00              CMP      r4,#0                 ;576
000578  d001              BEQ      |L1.1406|
00057a  4620              MOV      r0,r4                 ;578
00057c  e7dc              B        |L1.1336|
                  |L1.1406|
00057e  af01              ADD      r7,sp,#4              ;580
000580  e000              B        |L1.1412|
                  |L1.1410|
000582  2700              MOVS     r7,#0                 ;584
                  |L1.1412|
000584  a810              ADD      r0,sp,#0x40           ;588
000586  7903              LDRB     r3,[r0,#4]            ;588
000588  463a              MOV      r2,r7                 ;588
00058a  7a01              LDRB     r1,[r0,#8]            ;588
00058c  4630              MOV      r0,r6                 ;588
00058e  df72              SVC      #0x72                 ;588
000590  e7d2              B        |L1.1336|
                          ENDP

                  uint16_encode PROC
;;;119     */
;;;120    static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
000592  4602              MOV      r2,r0
;;;121    {
;;;122        p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
000594  700a              STRB     r2,[r1,#0]
;;;123        p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
000596  20ff              MOVS     r0,#0xff
000598  0200              LSLS     r0,r0,#8
00059a  4010              ANDS     r0,r0,r2
00059c  1200              ASRS     r0,r0,#8
00059e  7048              STRB     r0,[r1,#1]
;;;124        return sizeof(uint16_t);
0005a0  2002              MOVS     r0,#2
;;;125    }
0005a2  4770              BX       lr
;;;126        
                          ENDP

                  |L1.1444|
                          DCD      0x0000ffff
